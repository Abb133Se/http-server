package server

import "strings"

// HandlerFunc defines the function signature for all HTTP route handlers.
//
// A handler receives a parsed HTTP request and returns a Response struct.
// It should not directly write to the network connection; instead, the server
// takes care of serializing and sending the Response.
//
// Example:
//
//	func helloHandler(req *Request) Response {
//	    return Response{
//	        Version: HTTPVersion,
//	        Status:  200,
//	        Reason:  "OK",
//	        Headers: map[string]string{"Content-Type": "text/plain"},
//	        Body:    "Hello, World!",
//	    }
//	}
type HandlerFunc func(req *Request) Response

// route represents a single routing rule.
//
// Fields:
//   - path: The path to match against (e.g., "/about").
//   - handler: The function invoked when the path matches.
//   - prefix: Whether the path should be matched by prefix instead of exact equality.
//
// Notes:
//   - If prefix is true, the request path must start with the given route path.
//   - If prefix is false, the request path must equal the given route path.
type route struct {
	path    string
	handler HandlerFunc
	prefix  bool // if true, match by prefix instead of exact
}

// Router is a lightweight HTTP request router.
//
// It maintains a list of routes and matches incoming requests to the
// appropriate handler. Each route can be registered for exact or prefix-based
// matching. The router returns a 404 Not Found response if no route matches.
//
// Features:
//   - Exact path matching (e.g., "/").
//   - Prefix-based matching (e.g., "/echo/").
//   - Graceful fallback to 404 if no route applies.
//
// Example:
//
//	router := NewRouter()
//	router.Handle("/", rootHandler)
//	router.HandlePrefix("/echo/", echoHandler)
//	resp := router.Route(&Request{Path: "/echo/hello"})
type Router struct {
	routes []route
}

// NewRouter creates and initializes a new Router with no predefined routes.
//
// Returns:
//   - *Router: A pointer to a Router instance ready to register routes.
func NewRouter() *Router {
	return &Router{routes: []route{}}
}

// Handle registers a handler for an exact path match.
//
// Parameters:
//   - path: The request path to match (e.g., "/about").
//   - handler: The function responsible for handling requests to this path.
//
// Notes:
//   - Paths are checked in the order they were registered.
//   - Multiple handlers for the same path are allowed, but only the first
//     matching handler will be used.
func (r *Router) Handle(path string, handler HandlerFunc) {
	r.routes = append(r.routes, route{path: path, handler: handler, prefix: false})
}

// HandlePrefix registers a handler for prefix-based path matching.
//
// Parameters:
//   - path: The path prefix to match (e.g., "/api/").
//   - handler: The function responsible for handling requests to this prefix.
//
// Behavior:
//   - Any request path starting with the given prefix will trigger this handler.
//   - Useful for implementing grouped routes like `/api/v1/...`.
func (r *Router) HandlePrefix(path string, handler HandlerFunc) {
	r.routes = append(r.routes, route{path: path, handler: handler, prefix: true})
}

// Route matches an HTTP request to the appropriate handler and returns a response.
//
// Behavior:
//   - Iterates over registered routes in the order they were added.
//   - For prefix routes: Uses strings.HasPrefix to check for matches.
//   - For exact routes: Compares paths with equality.
//   - Returns the first matching handler's response.
//   - If no routes match, returns a default 404 Not Found response.
//
// Parameters:
//   - req: The parsed HTTP request to route.
//
// Returns:
//   - Response: The HTTP response generated by the matched handler or a 404.
func (r *Router) Route(req *Request) Response {
	for _, route := range r.routes {
		if route.prefix && strings.HasPrefix(req.Path, route.path) {
			return route.handler(req)
		}
		if !route.prefix && req.Path == route.path {
			return route.handler(req)
		}
	}

	return Response{
		Version: HTTPVersion,
		Status:  404,
		Reason:  "Not Found",
		Headers: map[string]string{"Content-Type": "text/plain"},
		Body:    "404 page not found",
	}
}
